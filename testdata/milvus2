经验3 - 合理选择流式插入和批量导入Mivus原生支持流批一体，同时支持流式写入和批式写入(BulkInsert)两种模式。绝大多数用户在最初接触Milvus的时候，都会选择流式写入，这种方式实时性较好，同时也避免了批式写入小文件带来的Compaction压力。如果有大量离线写入的场景，建议使用BulkInsert，原因是BulkInsert不会对查询性能造成太大的影响，并且也大大减少了流式写入对消息队列产生的压力。如何合理选择流式还是批式写入呢：单次写入超过100MB 以上，建议选择批式写入希望尽可能减少写入对线上查询的影响，建议选择批式写入希望写入实时可见，建议选择流式写入单次写入小于10MB以下，建议选择流式写入在选择好写入方式的基础上，还有几个经验需要关注：尽可能批量写入，整体吞吐会更高，建议每次写入的大小控制在10M单个Shard的流式写入量不建议超过10M/sDatanode多于Shard的情况下，部分DataNode可能无法获得负载导入目前支持的文件大小上限是1GB，接下来会支持更大的导入文件大小上限不建议频繁导入小文件，会给compaction带来比较大的压力经验4 - 谨慎使用标量过滤，删除特性等特性作为数据库，Milvus支持了删除，标量过滤, TimeTravel等高级特性。如果不了解底层原理，使用这些高级功能可能会对稳定性和性能造成比较严重的影响，以下是一些使用注意事项：Milvus使用的是前过滤，即先做标量过滤生成Bitset，在向量检索的过程中基于Bitset去除掉不满足条件的entity。对于HNSW这一类的图索引而言，标量过滤并不会加速查询，反而可能导致性能变差。特别是对于过滤性很强的条件（比如PK=1这种全局唯一的条件），标量过滤甚至会导致单次查询的时间长于爆搜。针对这种情况，用户也可以选择通过后过滤的方式绕过，先基于Milvus查出TopK的数据，在基于其他数据库进行过滤。对于过滤条件相对比较确定的场景，使用Partition把数据进行物理分区，在查询的时候指定Partition性能更好。Milvus的删除是标记删除，在compaction时会清理，因此删除的数据依然会占据内存。大量删除也会造成查询性能下降，同时大量compaction可能造成建索引压力变大等一系列影响。在需要大量频繁删除的场景，可能需要进行一些compaction参数的调整，保证删除的数据能够被及时清理。Milvus支持了数据自动过期功能（TTL），可以定时清理过期数据如果需要全量更新一个Collection的数据，推荐使用新建表 + 导入数据 + Alias切换的方案制定Output field时，如果要获取标量字段，会从对象存储上获取，吞吐和延迟都会收到较大影响当然，Milvus后续的版本会对以上能力做针对性的优化，尤其是删除和标量过滤的场景。Milvus新一代的标量执行引擎也已经在开发中，欢迎大家参与给出更多有建设性的意见。